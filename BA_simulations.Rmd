---
title: "BA_simulations"
author: "Lina Elkj√¶r Pedersen"
date: "11/24/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Libraries}

library(tidyverse)
#install.packages("R2jags")
library(R2jags)
library(coda)
library(boot)
library(brms)
library(ggplot2)
set.seed(1997)

```



```{r Structure of data}
## First, we set our data structure

# We have i participants (here 100)
i = 100
# participants have different genders (2)
g = 2
# each participant conducts n trials (8)
n = 8

# Let's now create the baseline data and combine it in a df
# Baseline data doesn't contain the output variable yet
id = rep(c(1:i), each=n) # creates i participants with each n rows
trial = rep(c(1:n), i) # repeat 1 to n trials for i participants
gender = rep(c(0,1), i/2, each=n) # repeat i/2 so that we get half female, half male

# And combine
data <- tibble(id, gender, trial) %>%
    arrange(id, trial)
View(data)
```


```{r RATE as outcome variable}
#Creating a rate. Here the rate is equally likely to be any value between 0 and 1. 
rate = runif(i, 0, 1)

rate %>% # what does this look like? We got what we wanted. There is some variation, but if we had more datapoints it would be good. 
    tibble() %>%
    ggplot(aes(rate)) +
    geom_density(color = "blue", size=2)

mu = .6 #the mean
kappa = 22 # kappa = the spread away from the mean. 

alpha = (kappa - 1) * mu 
beta = (kappa - 1) * (1 - mu)

# Seeing what a distribution with mean 0.6 and kappa 22 looks like (NO DATA IS ADDED) #Looks good
tibble(rate = rbeta(10000, alpha, beta)) %>%
    ggplot(aes(rate)) +
    geom_density(color = "blue", size=2) +
    xlim(0, 1)

# Let's write a function that reparametrise the beta distribution and draw samples
#We do this because we want to add mu and kappa in the function instead of alpha and beta, but the function rbeta only takes the input alpha and beta. We therefore tells it what to do with our mu and kappa to calculate alpha and beta.
mu_rbinom <- function(n, mu, kappa){
    alpha = (kappa - 1) * mu
    beta = (kappa - 1) * (1 - mu)

    return(rbeta(n, alpha, beta))
}

# So now let's include Gender
# We have 2 separate population (gender 0 and 1)
# We can model them as having 2 different means but the same variation
# (Although we could also assume different variance)
mu_0 <- .5   #Mean of gender 0
mu_1 <- .7   #Mean of gender 1
kappa = 22   #Same spread 

rates <- ifelse(rep(c(0,1), i/2) == 1, # recreate list of genders
                    mu_rbinom(i, mu_1, kappa), # if gender = 1, use mu_1
                    mu_rbinom(i, mu_0, kappa)) # if gender = 0, use mu_0


# add to prexisting data, repeating each value 8 times (so each participant has the same rate for all 8 tries)
data <- data  %>%
    mutate(rate = rep(rates, each = 8))
# plot to check
data %>%
    ggplot(aes(rate)) +
        geom_density(aes(fill=factor(gender)), alpha = .6) +
        geom_density(color = "red", size = 2) # super imposing the overall distribution

# generate draws for each rate
data <- data  %>%
    mutate(answer = map2(1, rate, rbernoulli) %>%
    unlist() %>% # output is a matrix, let's simplify it
    as.numeric() # transform from TRUE/FALSE to 1/0
    ) %>%
    # recalculate sums
    group_by(id) %>%
    mutate( sum = cumsum(answer)) %>%
    ungroup()


#PLOTS
# Rate of answers in time
# We see that the mean of gender0 is smaller than the mean of gender 1. This is what we asked it to do so the simulations seem good.
data %>%
    group_by(id) %>%
    ggplot(aes(trial,answer)) +
    # This is a bit clearer to read than the line plot
    geom_jitter(aes(color=factor(gender),group=id), width=.15, height=.15) +
    # Fat line for mean, one per gender
    geom_line(data=summarise(group_by(data, gender, trial), answer = mean(answer)),
                aes(color=factor(gender)), size=2)
# Cumsum
data %>%
    ggplot(aes(trial, jitter(sum, factor = .25), color=factor(gender))) +
    geom_line(aes(group=id)) +
    geom_line(data=summarise(group_by(data, gender, trial), sum = mean(sum)), size=2)
```


```{r RT as outcome variable}

#Creating a baseline reaction time. Here the response time is equally likely to be any value between 1000ms and 48048ms (the time when the sound is stopped). 
#RT_baseline <- runif(i, 1000, 48048)                     # Draw i gamma distributed values
RT_baseline <- rgamma(i, shape=6 ,scale=1000)   


RT_baseline %>% # what does this look like? It looks okay. However this is probably not realistic, the responsetimes cannot get long enough. #Probably models response time after an increment in soundlevel.
    tibble() %>%
    ggplot(aes(RT_baseline)) +
    geom_density(color = "blue", size=2)



data <- data  %>%
    mutate(#RT_baseline = rep(RT_baseline, each = 8),
           RT = rnorm(800, mean=RT_baseline/100, sd=8)) #NB I divided RT with 100 in order to make the sd have an effect


## quick look
# Makes sense that with maximum entropy, overall mean is around .5
# Answers in time
data %>%
    group_by(id) %>%
    ggplot(aes(trial,jitter(RT, factor = .25))) + # a bit of jitter to avoid overplotting
    # one line per id, colored per gender
    geom_line(aes(color=factor(gender),group=id), position = position_dodge(.4)) +
    # Fat line for mean, one per gender
    geom_line(data=summarise(group_by(data, gender, trial), RT = mean(RT)),
                aes(color=factor(gender)), size=2)


prior <- get_prior(data = data, family = gaussian(), RT ~ 1 + (1| gender) + (1| gender:id))

m1_prior <-
  brm(data = data,
      family = gaussian(),
      RT ~ 1 + gender + (1| gender)+ (1| gender:id),
     # prior = c(prior(normal(0, 1), class = Intercept),
               # prior(normal(0, 1), class = b),
               # prior(exponential(1), class = sd),
                #prior(normal(1, 0.5), class = sigma)),
      #prior = c(prior(student_t(3, 59.6, 26.7), class = Intercept),
                #prior(normal(0, 1), class = b),
               # prior(student_t(3, 0, 26.7), class = sd),
                #prior(student_t(3, 0, 26.7), class = sigma)),
     prior=c(prior,
             prior(normal(0, 1), class = b)),
      cores=2,
      sample_prior = "only",
      control = list(adapt_delta = 0.999, max_treedepth = 15))

pp_check(m1_prior, nsamples = 100)+
  xlim(-20,20)+
  ggtitle("Figure 1 - M1 Prior Predictive Check")

#################

m1 <-
  brm(data = data,
      family = gaussian(),
      RT ~ 1 + gender + (1| gender)+ (1| gender:id),
      prior=c(prior,
             prior(normal(0, 1), class = b)),
      cores = 2,
      sample_prior = TRUE,
      control = list(adapt_delta = 0.999, max_treedepth = 15))


pp_check(m1, nsamples = 100)+
  xlim(-20,20)+
  ggtitle("Figure 2 - M1 Posterior Predictive Check")
summary(m1)
```


```{r}
get_prior(data = data, family = Gamma(), RT ~ 1 + (1| gender) + (1| gender:id))

m1_prior <-
  brm(data = data,
      family = Gamma(),
      RT ~ 1 + gender + (1| gender)+ (1| gender:id),
      #prior = c(prior(normal(0, 1), class = Intercept),
                #prior(normal(0, 1), class = b),
                #prior(exponential(1), class = sd)),
      prior = c(prior(student_t(3, 0, 2.5), class = Intercept),
                prior(normal(0, 1), class = b),
                prior(student_t(3, 0, 2.5), class = sd),
                prior(gamma(0.01, 0.01), class = shape)),
     #prior=prior,
      cores=2,
      sample_prior = "only",
      control = list(adapt_delta = 0.999, max_treedepth = 15))

pp_check(m1_prior, nsamples = 100)+
  xlim(0,2000)+
  ggtitle("Figure 1 - M1 Prior Predictive Check")

#################

m1 <-
  brm(data = data,
      family = gaussian(),
      RT ~ 1 + gender + (1| gender)+ (1| gender:id),
      prior=c(prior,
             prior(normal(0, 1), class = b)),
      cores = 2,
      sample_prior = TRUE,
      control = list(adapt_delta = 0.999, max_treedepth = 15))


pp_check(m1, nsamples = 100)+
  xlim(-20,20)+
  ggtitle("Figure 2 - M1 Posterior Predictive Check")
summary(m1)
```

